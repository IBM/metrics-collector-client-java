/*-------------------------------------------------------------------------------
 Copyright IBM Corp. 2015

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-------------------------------------------------------------------------------*/
package com.ibm.bluemix.deploymenttracker.client;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.TimeZone;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.List;

import com.ibm.bluemix.deploymenttracker.util.JSONUtil;
import com.ibm.json.java.JSON;
import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;

/**
 * Use this simple class to track how many times a Java based VCAP_APPLICATION was started.
 * Only one attempt to track is made. The class logs output to the STDOUT stream and STDERR stream 
 * (if a problem occurred). 
 *
 */
public class CFJavaTrackerClient {

	// client tracker source code download location (informational only)
	private static final String TRACKER_SRC_URL = "https://github.com/IBM/metrics-collector-client-java";

	// client tracker version
	private static final String CLIENT_VERSION = "0.1.0";
	
	// default URL to which tracking requests are sent
	private static final String DEFAULT_TRACKER_URL = "https://metrics-tracker.mybluemix.net/api/v1/track";
	
	// tracking request property names
	public static final String KEYWORD_APPLICATION_ID = "application_id";           // defined in VCAP_APPLICATION env property 
	public static final String KEYWORD_APPLICATION_INSTANCE_INDEX = "instance_index";  // defined in VCAP_APPLICATION env property
	public static final String KEYWORD_APPLICATION_NAME = "application_name";		// defined in VCAP_APPLICATION env property
	public static final String KEYWORD_APPLICATION_VERSION = "application_version"; // defined in VCAP_APPLICATION env property 
	public static final String KEYWORD_APPLICATION_URIS = "application_uris";       // defined in VCAP_APPLICATION env property
	public static final String KEYWORD_SPACE_ID = "space_id";                       // defined in VCAP_APPLICATION env property
	public static final String KEYWORD_REPOSITORY_URL = "repository_url";           // defined by deployment tracker service
	public static final String KEYWORD_CODE_VERSION = "code_version";               // defined by deployment tracker service
	public static final String KEYWORD_REQUEST_DATE = "date_sent";					// defined by deployment tracker service
	public static final String KEYWORD_RUNTIME = "runtime"; 			            // defined by deployment tracker service
	public static final String KEYWORD_PLANS = "plans"; 			                // defined by deployment tracker service
	public static final String KEYWORD_CUSTOM_TRACKER_URL = "custom_tracker_url";	// defined by deployment tracker client
	public static final String KEYWORD_BOUND_VCAP_SERVICES = "bound_vcap_services";	// defined in VCAP_SERVICES env property
	public static final String KEYWORD_CF_API = "cf_api";	                        // defined in CF_API env property
	public static final String KEYWORD_BOUND_SERVICES = "bound_services"; 			// defined by deployment tracker service

		
	// key is generated by TrackingRequest.getTrackingKey()
	private static HashMap<String,TrackingRequest> trackingHistory = new HashMap<String,TrackingRequest>();
	
	/**
	 * Constructor.
	 */
	public CFJavaTrackerClient() {
		
	} // constructor
	
	/**
	 * Submits a tracking request that does not include optional application package information
	 */
	public void track() {
		TrackingRequest tr =  createTrackingRequest(null);
		processTrackingRequest(tr);
	} // method track(JSONObject)
	
	/**
	 * Submits a tracking request to the default tracking service URL that includes optional application package information. 
	 * @param configFile Required metadata information
	 */
	public void track(JSONObject configFile) {
		TrackingRequest tr = createTrackingRequest(configFile);
		processTrackingRequest(tr);
	} // method track(JSONObject)

	/**
	 * Submits a tracking request to a custom tracking service URL that includes optional application package information.	 
     * @param customurl the URL of a tracking service to which the request is to be sent. customurl is ignored if the value is null or an empty string
	 * @param configFile Required metadata information
	 */
	public void track(String customurl, JSONObject configFile) {
		TrackingRequest tr =  createTrackingRequest(configFile);
		// override tracker URL
		tr.setTrackingURL(customurl);		
		processTrackingRequest(tr);
	} // method track(String)
	
	/**
	 * Process the specified tracking request. If trackingrequest is null, this method does nothing.
	 * @param trackingrequest The request to be processed.
	 */
	private void processTrackingRequest(TrackingRequest trackingrequest) {
		
		if(trackingrequest == null)
		 return; // nothing to do
		
			HttpURLConnection con = null;
			URL url = null;
			DataOutputStream dos = null;
			
			try {
				
				if(! trackingHistory.containsKey(trackingrequest.getTrackingKey())) {
					
					// mark application as tracked (default response code 0 = not sent)
					trackingHistory.put(trackingrequest.getTrackingKey(),trackingrequest);
					
					// register the calling application with deployment tracker 			  
					url = new URL(trackingrequest.getTrackingURL());
										
					con = (HttpURLConnection) url.openConnection();
					// prevent infinite wait (where supported) if the tracker service isn't running or taking too much time to respond
					con.setConnectTimeout(2000);
					con.setReadTimeout(2000);
					// set request properties
					con.setRequestMethod("POST");
					con.setRequestProperty("Content-Type", "application/json");
					con.setDoOutput(true);
					// send tracking information
					dos = new DataOutputStream(con.getOutputStream());
					dos.writeBytes(trackingrequest.getRequestData().serialize());	
					dos.flush();
					dos.close();
					dos = null;
	
					// document request status
					trackingrequest.setRequestStatus(con.getResponseCode());
					trackingHistory.put(trackingrequest.getTrackingKey(),trackingrequest);
					
					// debug only
					System.out.println("[Metrics-Collector-Client-Java] Tracking request for application " + trackingrequest.getRequestingAppName() + " returned: " + con.getResponseCode() + " " + con.getResponseMessage());
								
					// display request and response details if return code does not indicate success 
					//   1xx: Informational
				    //   2xx: Success
				    //   3xx: Redirection
				    //   4xx: Client Error
				    //   5xx: Server Error 
					if(con.getResponseCode() >= 300) {
						
						System.err.println("[Metrics-Collector-Client-Java] Tracking request for application " + trackingrequest.getRequestingAppName() + ": " + trackingrequest.getRequestData().serialize());
						
						BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
	
						if (in != null) {
							String responseLine = null;
							while ((responseLine = in.readLine()) != null) {
								System.err.println(responseLine);	
							}
							in.close();
							in = null;
						}
					}
					
					
			  } // if (! trackingHistory ...
			}
			// catch all
			catch(Exception ex) {
				System.err.println("[Metrics-Collector-Client-Java] An error occurred while trying to track application " + trackingrequest.getRequestingAppName() + ": "+ ex.getClass().getName() + ":" + ex.getMessage());
				ex.printStackTrace(System.err);
			}
			finally {
				
				// cleanup
				if(dos != null) {
					try {
					dos.close();
					}
					catch(Exception ex){
						// ignore
					}
					dos = null;
				}
				
				if(con != null) {
					con.disconnect();
					con = null;
				}
				url = null;
			} // finally			
		
	} // end method
						
	/**
	 * Returns a list of recent tracking requests
	 * @return list of tracking requests, never null
	 */
	public Collection<TrackingRequest> getTrackingRequests() {
		return trackingHistory.values();
	} // end method
	
	/**
	 * Returns the CF client tracker version
	 * @return version string
	 */
	public String getVersion() {
		return CLIENT_VERSION;
	} // end method getVersion

	/**
	 * Returns the URL where the client tracker source code can be downloaded or null if not published
	 * @return the tracking client source code download URL
	 */
	public String getClientSourceURL() {
		return TRACKER_SRC_URL;
	} // end method getClientSourceURL
	
	/**
	 * Creates a tracking request.
	 * @return a complete tracking request or null in case of a problem
	 */
	private TrackingRequest createTrackingRequest(JSONObject configFile) {
		
		TrackingRequest trackingrequest = null;
		
		// 'VCAP_APPLICATION' is in JSON format, it contains useful information about a deployed application
		String envApp = System.getenv("VCAP_APPLICATION");
			
		// Only proceed if we have access to the metadata we want to track
		JSONObject payload = null;
		payload = new JSONObject();
		String language = "java";

		// process optional application description (refer to https://github.com/IBM/metrics-collector-client-java)
		// process metadata in repository.yaml 
		if(configFile != null){
			try {
				JSONObject yamlconfig = new JSONObject();
				if(configFile.get("id") != null){
			   		yamlconfig.put("repository_id", configFile.get("id"));
			   	}else{
			   		yamlconfig.put("repository_id", "");
			   	}
			   	if(configFile.get("runtimes") != null){
			   		yamlconfig.put("target_runtimes", configFile.get("runtimes"));
			   	}else{
			   		yamlconfig.put("target_runtimes", "");
			   	}
			   	if(configFile.get("services") != null){
			   		yamlconfig.put("target_services", configFile.get("services"));
			   	}else{
			   		yamlconfig.put("target_services", "");
			   	}
			   	if(configFile.get("event_id") != null){
			   		yamlconfig.put("event_id", configFile.get("event_id"));
			   	}else{
			   		yamlconfig.put("event_id", "");
			   	}
			   	if(configFile.get("event_organizer") != null){
			   		yamlconfig.put("event_organizer", configFile.get("event_organizer"));
			   	}else{
			   		yamlconfig.put("event_organizer", "");
			   	}
			    payload.put("config", yamlconfig);	
			    if(configFile.get("language") != null){
			    	language = (String)configFile.get("language");
			    }
			}catch(Exception ex) {
				//Repository.yaml format error.
			}
		}

		// identify the application's runtime environment; for applicaitons tracked by this client the runtime is "[WebSphere] liberty"
		payload.put(KEYWORD_RUNTIME, language);

		if(envApp != null) {
			
			
			try {				
				JSONObject obj	= (JSONObject)JSON.parse(envApp);			
				SimpleDateFormat dateFormatGmt = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.sss'Z'"); // ISO 8601 (extended format)
				dateFormatGmt.setTimeZone(TimeZone.getTimeZone("GMT")); // not strictly needed but added for clarity
				payload.put(KEYWORD_REQUEST_DATE,dateFormatGmt.format(new Date()));					
				// VCAP_APPLICATION properties
				payload.put(KEYWORD_APPLICATION_ID, (String) obj.get(KEYWORD_APPLICATION_ID));				// singleton per VCAP_APPLICATION definition
				payload.put(KEYWORD_APPLICATION_INSTANCE_INDEX, (Long) obj.get(KEYWORD_APPLICATION_INSTANCE_INDEX));	// singleton per VCAP_APPLICATION definition
				payload.put(KEYWORD_APPLICATION_NAME, (String) obj.get(KEYWORD_APPLICATION_NAME));			// singleton per VCAP_APPLICATION definition
				payload.put(KEYWORD_APPLICATION_VERSION, (String) obj.get(KEYWORD_APPLICATION_VERSION));    // singleton per VCAP_APPLICATION definition
				payload.put(KEYWORD_APPLICATION_URIS, (JSONArray) obj.get(KEYWORD_APPLICATION_URIS));       // array per VCAP_APPLICATION definition
				payload.put(KEYWORD_SPACE_ID, (String) obj.get(KEYWORD_SPACE_ID));                          // singleton per VCAP_APPLICATION definition
				payload.put("provider", (String) obj.get(KEYWORD_CF_API));                              // singleton per VCAP_APPLICATION definition
			

				// 'VCAP_SERVICES' is a JSON formatted environment variable in Cloud Foundry, identifying the services that are bound to the application
				String vcapServicesJSON = System.getenv("VCAP_SERVICES");
				JSONArray boundServices = new JSONArray();
				if(vcapServicesJSON != null) {
					JSONObject vcapServices	= (JSONObject)JSON.parse(vcapServicesJSON);
					/* 
						Sample vcapServices

						{
						   "cloudantNoSQLDB": [
						      {
						         "name": "deployment-tracker-db",
						         "label": "cloudantNoSQLDB",
						         "plan": "Shared",
						         "credentials": {
						         	...
						         }
						      },
						      ...
						      {
						         "name": "other-cloudant-db",
						         "label": "cloudantNoSQLDB",
						         "plan": "Shared",
						         "credentials": {
						         	...
						         }
						      }
						   ],
						   ...  
						}
					*/
					Iterator<String> serviceLabelIterator = vcapServices.keySet().iterator();
					// if at least service is bound to the tracked application collect the relevant information
					if(serviceLabelIterator.hasNext()) {
						JSONObject boundVcapServices = new JSONObject(),
						           serviceInstance = null,
						           serviceProperty = null;
						JSONArray serviceInstances = null,
								  servicePlans = null;
						Iterator<JSONObject> serviceInstanceIterator = null;
						String serviceLabel = null;

						// iterate through list of services, count the number of instances and record plan information
						while(serviceLabelIterator.hasNext()) {
							serviceLabel = (String) serviceLabelIterator.next();
							serviceProperty = new JSONObject();
							serviceInstances = (JSONArray) vcapServices.get(serviceLabel);
							// add "count" property to tracking payload , identifying the number of instances for this service label
							serviceProperty.put("count", serviceInstances.size());
							/*
                                "cloudantNoSQLDB": {	// serviceLabel
							      "count": 2 			// serviceProperty (number of service instances)
							    }
                             */

							// iterate through service instances and extract plan information
							servicePlans = new JSONArray();
							serviceInstanceIterator = serviceInstances.iterator();
							while(serviceInstanceIterator.hasNext()) {
								serviceInstance = serviceInstanceIterator.next();
								if(serviceInstance.containsKey("plan")) {
									servicePlans.add(serviceInstance.get("plan"));	
								}
								if(serviceInstance.containsKey("name")) {
									boundServices.add(serviceInstance.get("name"));	
								}
							}

							// add plan information (some services, such as user-provided services don't have plans)
							if(! servicePlans.isEmpty()) {
								serviceProperty.put(KEYWORD_PLANS, servicePlans);
								/*
                                  "cloudantNoSQLDB": {	// serviceLabel
							      	"count": 2, 		// serviceProperty (number of service instances)
									"plans": [
												"Shared",
												"Shared"
											 ]
							      }
                             	*/	
							}

							boundVcapServices.put(serviceLabel, serviceProperty);
						}
						/*
							"bound_vcap_services": {
                                "cloudantNoSQLDB": {	// serviceLabel
							    	"count": 2, 		// serviceProperty (number of service instances)
									"plans": [
												"Shared",
												"Shared"
											 ]
							    }
						    }
						 */
						payload.put(KEYWORD_BOUND_VCAP_SERVICES, boundVcapServices);
						payload.put(KEYWORD_BOUND_SERVICES, boundServices);
					}
				}	 
								
			} // try
			catch(Exception ex) {
				System.err.println("[Metrics-Collector-Client-Java] An error occurred while collecting tracking information: "+ ex.getClass().getName() + ":" + ex.getMessage());
				ex.printStackTrace(System.err);
				// invalidate the created objects
				payload = null;
				trackingrequest = null;
			}
			
		} // if(envApp != null) 
		else{
			payload.put(KEYWORD_SPACE_ID, System.getProperty("user.name"));
		}
		try{
			payload.serialize(); 
			trackingrequest = new TrackingRequest(payload);
			// assign the tracker service URL
			if(System.getenv("DEPLOYMENT_TRACKER_URL") == null)
				trackingrequest.setTrackingURL(DEFAULT_TRACKER_URL);	                        // use hard-wired default
			else 
				trackingrequest.setTrackingURL(System.getenv("DEPLOYMENT_TRACKER_URL"));		// override default by using the URL specified by the environment variable
		}catch(Exception ex) {
			// verify that the tracking information can be converted to JSON
			// serialize() throws an exception in case of a problem
			ex.printStackTrace(System.err);
		}
		return trackingrequest;
	} // end method createTrackingRequest
	
} // end class